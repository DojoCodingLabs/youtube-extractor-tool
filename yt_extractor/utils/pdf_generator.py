"""PDF generation utilities for converting markdown summaries to PDF."""

import re
from pathlib import Path
from typing import Dict, Any, Optional
import markdown2
from weasyprint import HTML, CSS
import yaml


class PDFGenerator:
    """Converts markdown video summaries to professionally styled PDFs."""

    def __init__(self):
        """Initialize PDF generator."""
        self.css_template = self._get_css_template()

    def generate_pdf(
        self,
        markdown_path: Path,
        output_path: Path,
        include_metadata: bool = True,
        page_size: str = "letter",
        font_size: int = 11,
    ) -> Path:
        """
        Generate a PDF from a markdown file.

        Args:
            markdown_path: Path to the markdown file
            output_path: Path where PDF should be saved
            include_metadata: Whether to include metadata section
            page_size: Page size (letter, a4)
            font_size: Base font size in points

        Returns:
            Path to the generated PDF file

        Raises:
            ValueError: If markdown file is invalid
            IOError: If file operations fail
        """
        # Read and parse markdown
        content = markdown_path.read_text(encoding="utf-8")
        metadata, body = self._parse_frontmatter(content)

        # Convert markdown to HTML
        html_body = markdown2.markdown(
            body,
            extras=[
                "fenced-code-blocks",
                "tables",
                "header-ids",
                "task_list",
                "strike",
            ]
        )

        # Build complete HTML document
        html_content = self._build_html(
            metadata=metadata,
            body=html_body,
            include_metadata=include_metadata,
            font_size=font_size,
        )

        # Generate PDF
        css = self._get_css(page_size=page_size, font_size=font_size)
        html_doc = HTML(string=html_content)
        html_doc.write_pdf(output_path, stylesheets=[CSS(string=css)])

        return output_path

    def _parse_frontmatter(self, content: str) -> tuple[Dict[str, Any], str]:
        """
        Parse YAML frontmatter from markdown content.

        Args:
            content: Full markdown content with frontmatter

        Returns:
            Tuple of (metadata dict, body content)
        """
        # Match YAML frontmatter
        pattern = r'^---\s*\n(.*?\n)---\s*\n(.*)$'
        match = re.match(pattern, content, re.DOTALL)

        if not match:
            # No frontmatter, return empty metadata
            return {}, content

        yaml_content = match.group(1)
        body = match.group(2)

        try:
            metadata = yaml.safe_load(yaml_content)
            return metadata or {}, body
        except yaml.YAMLError:
            # If YAML parsing fails, treat entire content as body
            return {}, content

    def _build_html(
        self,
        metadata: Dict[str, Any],
        body: str,
        include_metadata: bool,
        font_size: int,
    ) -> str:
        """
        Build complete HTML document.

        Args:
            metadata: Parsed YAML metadata
            body: HTML-converted markdown body
            include_metadata: Whether to include metadata section
            font_size: Base font size

        Returns:
            Complete HTML document string
        """
        # Build metadata section
        metadata_html = ""
        if include_metadata and metadata:
            metadata_html = self._build_metadata_section(metadata)

        # Build document
        html = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{metadata.get('title', 'Video Summary')}</title>
</head>
<body>
    {metadata_html}
    <div class="content">
        {body}
    </div>
    <div class="footer">
        <p>Generated by YouTube Extractor Tool</p>
    </div>
</body>
</html>
"""
        return html

    def _build_metadata_section(self, metadata: Dict[str, Any]) -> str:
        """
        Build HTML for metadata section.

        Args:
            metadata: Parsed metadata dictionary

        Returns:
            HTML string for metadata section
        """
        html_parts = ['<div class="metadata">']

        # Title
        if title := metadata.get("title"):
            html_parts.append(f'<h1 class="video-title">{self._escape_html(title)}</h1>')

        # Video info
        info_items = []
        if channel := metadata.get("channel"):
            info_items.append(f'<strong>Channel:</strong> {self._escape_html(channel)}')
        if published := metadata.get("published"):
            # Format date nicely
            formatted_date = self._format_date(published)
            info_items.append(f'<strong>Published:</strong> {formatted_date}')
        if url := metadata.get("url"):
            info_items.append(f'<strong>URL:</strong> <a href="{url}">{url}</a>')
        if category := metadata.get("category"):
            info_items.append(f'<strong>Category:</strong> {self._escape_html(category)}')

        if info_items:
            html_parts.append('<div class="video-info">')
            html_parts.append(' | '.join(info_items))
            html_parts.append('</div>')

        # Tags
        if tags := metadata.get("tags"):
            if isinstance(tags, list) and tags:
                tags_str = ', '.join(self._escape_html(str(tag)) for tag in tags[:10])
                html_parts.append(f'<div class="tags"><strong>Tags:</strong> {tags_str}</div>')

        html_parts.append('</div>')
        return '\n'.join(html_parts)

    def _format_date(self, date_str: str) -> str:
        """Format date string nicely."""
        # Handle YYYYMMDD format
        if len(date_str) == 8 and date_str.isdigit():
            year = date_str[:4]
            month = date_str[4:6]
            day = date_str[6:8]
            return f"{year}-{month}-{day}"
        return date_str

    def _escape_html(self, text: str) -> str:
        """Escape HTML special characters."""
        return (
            str(text)
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;")
            .replace("'", "&#39;")
        )

    def _get_css(self, page_size: str = "letter", font_size: int = 11) -> str:
        """
        Get CSS stylesheet for PDF.

        Args:
            page_size: Page size (letter, a4)
            font_size: Base font size in points

        Returns:
            CSS stylesheet string
        """
        # Determine page size
        if page_size.lower() == "a4":
            page_declaration = "@page { size: A4; margin: 2cm; }"
        else:
            page_declaration = "@page { size: letter; margin: 1in; }"

        css = f"""
{page_declaration}

@page {{
    @top-right {{
        content: "Page " counter(page) " of " counter(pages);
        font-size: 9pt;
        color: #666;
    }}
}}

* {{
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}}

body {{
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: {font_size}pt;
    line-height: 1.6;
    color: #333;
}}

.metadata {{
    background: #f8f9fa;
    padding: 20pt;
    margin-bottom: 30pt;
    border-radius: 8pt;
    page-break-after: avoid;
}}

.video-title {{
    font-size: {font_size + 8}pt;
    font-weight: 700;
    color: #1a1a1a;
    margin-bottom: 15pt;
    line-height: 1.2;
}}

.video-info {{
    font-size: {font_size - 1}pt;
    color: #555;
    margin-bottom: 10pt;
    line-height: 1.8;
}}

.tags {{
    font-size: {font_size - 2}pt;
    color: #666;
    margin-top: 10pt;
    font-style: italic;
}}

.content {{
    margin-bottom: 50pt;
}}

h1 {{
    font-size: {font_size + 6}pt;
    font-weight: 700;
    color: #1a1a1a;
    margin-top: 30pt;
    margin-bottom: 15pt;
    page-break-after: avoid;
    border-bottom: 2pt solid #e0e0e0;
    padding-bottom: 8pt;
}}

h2 {{
    font-size: {font_size + 4}pt;
    font-weight: 600;
    color: #2c3e50;
    margin-top: 25pt;
    margin-bottom: 12pt;
    page-break-after: avoid;
}}

h3 {{
    font-size: {font_size + 2}pt;
    font-weight: 600;
    color: #34495e;
    margin-top: 20pt;
    margin-bottom: 10pt;
    page-break-after: avoid;
}}

h4, h5, h6 {{
    font-size: {font_size}pt;
    font-weight: 600;
    color: #444;
    margin-top: 15pt;
    margin-bottom: 8pt;
    page-break-after: avoid;
}}

p {{
    margin-bottom: 12pt;
    text-align: justify;
    orphans: 3;
    widows: 3;
}}

ul, ol {{
    margin-left: 20pt;
    margin-bottom: 12pt;
}}

li {{
    margin-bottom: 6pt;
}}

blockquote {{
    border-left: 4pt solid #3498db;
    padding-left: 15pt;
    margin: 15pt 0;
    color: #555;
    font-style: italic;
}}

code {{
    background: #f4f4f4;
    padding: 2pt 4pt;
    font-family: "Courier New", Courier, monospace;
    font-size: {font_size - 1}pt;
    border-radius: 3pt;
}}

pre {{
    background: #f8f8f8;
    padding: 12pt;
    border-radius: 4pt;
    border-left: 3pt solid #3498db;
    margin: 15pt 0;
    overflow-x: auto;
    page-break-inside: avoid;
}}

pre code {{
    background: none;
    padding: 0;
}}

a {{
    color: #3498db;
    text-decoration: none;
}}

a:hover {{
    text-decoration: underline;
}}

table {{
    width: 100%;
    border-collapse: collapse;
    margin: 15pt 0;
    page-break-inside: avoid;
}}

th, td {{
    padding: 8pt;
    border: 1pt solid #ddd;
    text-align: left;
}}

th {{
    background: #f8f9fa;
    font-weight: 600;
}}

.footer {{
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    text-align: center;
    font-size: 8pt;
    color: #999;
    padding: 10pt;
}}

/* Page break controls */
.page-break {{
    page-break-before: always;
}}

.no-break {{
    page-break-inside: avoid;
}}
"""
        return css

    def _get_css_template(self) -> str:
        """Get default CSS template."""
        return self._get_css()
